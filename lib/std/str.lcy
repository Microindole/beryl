// Lency 标准库 - 字符串模块 (string.lcy)
// 提供字符串操作函数
//
// 核心字符串函数是编译器内置函数 (intrinsics)：
//   int     len(string s)                       - 字符串长度
//   string  trim(string s)                      - 去除首尾空白
//   Vec<string> split(string s, string delim)   - 按分隔符拆分
//   string  join(Vec<string> parts, string sep) - 用分隔符连接
//   string  substr(string s, int start, int len) - 提取子串

// ============== 字符串辅助函数 ==============

// 检查字符串是否为空
bool is_empty(string s) {
    return len(s) == 0
}

// 检查字符串是否以指定前缀开头
bool starts_with(string s, string prefix) {
    var prefix_len = len(prefix)
    if len(s) < prefix_len {
        return false
    }
    var head = substr(s, 0, prefix_len)
    return head == prefix
}

// 检查字符串是否以指定后缀结尾
bool ends_with(string s, string suffix) {
    var suffix_len = len(suffix)
    var s_len = len(s)
    if s_len < suffix_len {
        return false
    }
    var tail = substr(s, s_len - suffix_len, suffix_len)
    return tail == suffix
}

// 检查字符串是否包含子串
bool contains(string s, string sub) {
    var s_len = len(s)
    var sub_len = len(sub)
    
    if sub_len == 0 {
        return true
    }
    if s_len < sub_len {
        return false
    }
    
    // 简单的线性搜索
    var i = 0
    while i <= s_len - sub_len {
        var candidate = substr(s, i, sub_len)
        if candidate == sub {
            return true
        }
        i = i + 1
    }
    return false
}

// 重复字符串 n 次
string repeat(string s, int n) {
    if n <= 0 {
        return ""
    }
    
    var result = s
    var i = 1
    while i < n {
        result = result + s
        i = i + 1
    }
    return result
}

// 将字符串填充到指定长度 (右填充)
string pad_right(string s, int target_len, string pad_char) {
    var current_len = len(s)
    if current_len >= target_len {
        return s
    }
    
    var padding_needed = target_len - current_len
    var padding = repeat(pad_char, padding_needed)
    return s + padding
}

// 将字符串填充到指定长度 (左填充)
string pad_left(string s, int target_len, string pad_char) {
    var current_len = len(s)
    if current_len >= target_len {
        return s
    }
    
    var padding_needed = target_len - current_len
    var padding = repeat(pad_char, padding_needed)
    return padding + s
}

// 替换第一个匹配项
string replace_first(string s, string old, string new_str) {
    var s_len = len(s)
    var old_len = len(old)
    
    if old_len == 0 {
        return s
    }
    if s_len < old_len {
        return s
    }
    
    // 找到 old 的第一个位置
    var i = 0
    while i <= s_len - old_len {
        var candidate = substr(s, i, old_len)
        if candidate == old {
            // 找到了，拼接结果
            var before = substr(s, 0, i)
            var after = substr(s, i + old_len, s_len - i - old_len)
            return before + new_str + after
        }
        i = i + 1
    }
    return s
}

// 替换所有匹配项
string replace_all(string s, string old, string new_str) {
    if len(old) == 0 {
        return s
    }
    var parts = split(s, old)
    return join(parts, new_str)
}

// 查找子串的位置 (返回 -1 表示未找到)
int index_of(string s, string sub) {
    var s_len = len(s)
    var sub_len = len(sub)
    
    if sub_len == 0 {
        return 0
    }
    if s_len < sub_len {
        return -1
    }
    
    var i = 0
    while i <= s_len - sub_len {
        var candidate = substr(s, i, sub_len)
        if candidate == sub {
            return i
        }
        i = i + 1
    }
    return -1
}

// 将字符串转为大写 (仅 ASCII)
string to_upper(string s) {
    var result = ""
    var i = 0
    while i < len(s) {
        var c = s[i]
        // a-z: 97-122 -> A-Z: 65-90
        if c >= 97 {
            if c <= 122 {
                c = c - 32
            }
        }
        result = result + char_to_string(c)
        i = i + 1
    }
    return result
}

// 将字符串转为小写 (仅 ASCII)
string to_lower(string s) {
    var result = ""
    var i = 0
    while i < len(s) {
        var c = s[i]
        // A-Z: 65-90 -> a-z: 97-122
        if c >= 65 {
            if c <= 90 {
                c = c + 32
            }
        }
        result = result + char_to_string(c)
        i = i + 1
    }
    return result
}

// 反转字符串
string reverse(string s) {
    var result = ""
    var i = len(s) - 1
    while i >= 0 {
        result = result + char_to_string(s[i])
        i = i - 1
    }
    return result
}

// ============== 新增字符串函数 ==============

// 统计子串出现次数
int count(string s, string sub) {
    var sub_len = len(sub)
    if sub_len == 0 {
        return 0
    }
    var s_len = len(s)
    if s_len < sub_len {
        return 0
    }
    var n = 0
    var i = 0
    while i <= s_len - sub_len {
        var candidate = substr(s, i, sub_len)
        if candidate == sub {
            n = n + 1
            i = i + sub_len // 不重叠计数
        } else {
            i = i + 1
        }
    }
    return n
}

// 去除左侧空白
string trim_left(string s) {
    var i = 0
    var l = len(s)
    while i < l {
        var c = s[i]
        if c != 32 && c != 9 && c != 10 && c != 13 {
            return substr(s, i, l - i)
        }
        i = i + 1
    }
    return ""
}

// 去除右侧空白
string trim_right(string s) {
    var l = len(s)
    var i = l - 1
    while i >= 0 {
        var c = s[i]
        if c != 32 && c != 9 && c != 10 && c != 13 {
            return substr(s, 0, i + 1)
        }
        i = i - 1
    }
    return ""
}

// 获取指定位置的字符 (返回 ASCII int，越界返回 -1)
int char_at(string s, int index) {
    if index < 0 || index >= len(s) {
        return -1
    }
    return s[index]
}

// 从后往前查找子串位置 (返回 -1 表示未找到)
int last_index_of(string s, string sub) {
    var s_len = len(s)
    var sub_len = len(sub)
    if sub_len == 0 {
        return s_len
    }
    if s_len < sub_len {
        return -1
    }
    var i = s_len - sub_len
    while i >= 0 {
        var candidate = substr(s, i, sub_len)
        if candidate == sub {
            return i
        }
        i = i - 1
    }
    return -1
}
