// Lency 标准库 - 集合模块 (collections.lcy)
import std.core
// 提供集合类型和泛型操作
//
// Vec<T> 是编译时内置类型，基本操作由运行时提供。
// 本文件提供更高级的集合操作和 HashMap。

// ============== Vec 扩展方法 ==============
// Iterator trait、VecIterator、vec_iter 定义在 std.iterator 模块
import std.iterator

// ============== Pair 类型 ==============

// 泛型键值对
struct Pair<K, V> {
    K key
    V value
}

// 创建 Pair
Pair<K, V> make_pair<K, V>(K key, V value) {
    return Pair<K, V> { key: key, value: value }
}

// ============== Box 类型 ==============

// 简单的包装类型
struct Box<T> {
    T value
}

impl<T> Box<T> {
    // 获取值
    T get() {
        return this.value
    }

    // 设置值
    void set(T new_value) {
        this.value = new_value
    }
}

// 创建 Box
Box<T> box<T>(T value) {
    return Box<T> { value: value }
}

// ============== Vec 辅助函数 ==============
// 注意: 这些函数假设 Vec 已有 len/get/set 方法支持

// 查找元素的索引 (返回 -1 表示未找到)
// 使用 Eq trait 进行比较
int find_index_int(Vec<int> v, int target) {
    var i = 0
    while i < v.len() {
        if v.get(i) == target {
            return i
        }
        i = i + 1
    }
    return -1
}

// 查找字符串元素的索引
int find_index_string(Vec<string> v, string target) {
    var i = 0
    while i < v.len() {
        if v.get(i) == target {
            return i
        }
        i = i + 1
    }
    return -1
}

// 反转 Vec
void reverse<T>(Vec<T> v) {
    var left = 0
    var right = v.len() - 1
    while left < right {
        var tmp = v.get(left)
        v.set(left, v.get(right))
        v.set(right, tmp)
        left = left + 1
        right = right - 1
    }
}

// 获取 Vec 的最后一个元素
T last<T>(Vec<T> v) {
    return v.get(v.len() - 1)
}

// ============== 新增 Vec 辅助函数 ==============

// 生成整数序列 [start, end)
Vec<int> range(int start, int end) {
    var result: Vec<int> = vec![]
    var i = start
    while i < end {
        result.push(i)
        i = i + 1
    }
    return result
}

// 检查 Vec<int> 是否包含目标值
bool vec_contains_int(Vec<int> v, int target) {
    return find_index_int(v, target) != -1
}

// 检查 Vec<string> 是否包含目标值
bool vec_contains_string(Vec<string> v, string target) {
    return find_index_string(v, target) != -1
}

// Vec<int> 求和
int vec_sum(Vec<int> v) {
    var sum = 0
    var i = 0
    while i < v.len() {
        sum = sum + v.get(i)
        i = i + 1
    }
    return sum
}

// Vec<int> 最大值 (空 Vec 返回 0)
int vec_max(Vec<int> v) {
    if v.len() == 0 {
        return 0
    }
    var m = v.get(0)
    var i = 1
    while i < v.len() {
        var val = v.get(i)
        if val > m {
            m = val
        }
        i = i + 1
    }
    return m
}

// Vec<int> 最小值 (空 Vec 返回 0)
int vec_min(Vec<int> v) {
    if v.len() == 0 {
        return 0
    }
    var m = v.get(0)
    var i = 1
    while i < v.len() {
        var val = v.get(i)
        if val < m {
            m = val
        }
        i = i + 1
    }
    return m
}

// ============== 运行时 Vec FFI (供参考) ==============
//
// lency_vec_new(capacity)          -> *mut LencyVec
// lency_vec_push(vec, element)     -> void
// lency_vec_pop(vec)               -> i64
// lency_vec_len(vec)               -> i64
// lency_vec_get(vec, index)        -> i64
// lency_vec_set(vec, index, value) -> void
// lency_vec_free(vec)              -> void

// ============== HashMap ==============
// HashMap 通过运行时 FFI 实现。
// TODO: struct 包装暂不可用（返回 struct 的 codegen 问题），请直接使用函数形式：
//
// Int 键 HashMap:
//   var map = hashmap_int_new()
//   hashmap_int_insert(map, key, value)
//   var v = hashmap_int_get(map, key)
//   var exists = hashmap_int_contains(map, key)
//   var removed = hashmap_int_remove(map, key)
//   var size = hashmap_int_len(map)
//
// String 键 HashMap:
//   var map = hashmap_string_new()
//   hashmap_string_insert(map, key, value)
//   var v = hashmap_string_get(map, key)
//   var exists = hashmap_string_contains(map, key)
//   var removed = hashmap_string_remove(map, key)
//   var size = hashmap_string_len(map)

