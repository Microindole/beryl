// lencyc/syntax/lexer.lcy
// Lency Self-hosted Compiler - Minimal Lexer
// Scans basic operators and numbers. Unknown characters trigger T_ERROR.

import std.core
import std.char
import lencyc.syntax.token

struct Lexer {
    string source
    int start
    int current
    int line
    int column
}

Lexer make_lexer(string source) {
    return Lexer {
        source: source,
        start: 0,
        current: 0,
        line: 1,
        column: 1
    }
}

impl Lexer {
    bool is_at_end() {
        return this.current >= len(this.source);
    }

    string advance() {
        if this.is_at_end() {
            return " ";
        }
        var c = substr(this.source, this.current, 1);
        this.current = this.current + 1;
        this.column = this.column + 1;
        return c;
    }

    string peek() {
        if this.is_at_end() {
            return " ";
        }
        return substr(this.source, this.current, 1);
    }

    bool match_char(string expected) {
        if this.is_at_end() { return false; }
        if substr(this.source, this.current, 1) != expected { return false; }
        this.current = this.current + 1;
        this.column = this.column + 1;
        return true;
    }
    
    int peek_char() {
        if this.is_at_end() {
            return 0; // null char
        }
        return this.source[this.current];
    }
    
    // Generate normal token
    Token make_token_from(int kind) {
        var l = this.current - this.start;
        var lexeme = substr(this.source, this.start, l);
        // Note: Subtract current length to get start column
        return make_token(kind, lexeme, this.line, this.column - l);
    }
    
    // Generate error token
    Token error_token(string message) {
        return make_token(T_ERROR(), message, this.line, this.column);
    }
    
    // Skip whitespace and comments
    void skip_whitespace() {
        while !this.is_at_end() {
            var c = this.peek();
            if c == " " || c == "\r" || c == "\t" {
                var dummy = this.advance();
            } else { 
                if c == "\n" {
                    this.line = this.line + 1;
                    this.column = 1;
                    var dummy = this.advance();
                } else { 
                    // Handle // comments
                    if c == "/" {
                        // Peek next character
                        if this.current + 1 < len(this.source) {
                            var next = substr(this.source, this.current + 1, 1)
                            if next == "/" {
                                // Skip until newline
                                while !this.is_at_end() && this.peek() != "\n" {
                                    var dummy2 = this.advance()
                                }
                                continue // Continue for more whitespace/comments
                            }
                        }
                    }
                    return;
                }
            }
        }
    }
    
    // Parse identifiers and keywords
    Token identifier() {
        while is_alphanumeric(this.peek_char()) || this.peek_char() == 95 { // 95 is '_'
            var dummy = this.advance();
        }
        
        var l = this.current - this.start;
        var text = substr(this.source, this.start, l);
        
        var kind = T_IDENTIFIER();
        if text == "if" { kind = T_IF(); }
        if text == "else" { kind = T_ELSE(); }
        if text == "var" { kind = T_VAR(); }
        if text == "true" { kind = T_TRUE(); }
        if text == "false" { kind = T_FALSE(); }
        if text == "while" { kind = T_WHILE(); }
        if text == "struct" { kind = T_STRUCT(); }
        if text == "impl" { kind = T_IMPL(); }
        if text == "return" { kind = T_RETURN(); }
        if text == "void" { kind = T_VOID(); }
        if text == "int" { kind = T_INT(); }
        if text == "string" { kind = T_STRING(); }
        if text == "bool" { kind = T_BOOL(); }
        
        return this.make_token_from(kind);
    }
    
    // Parse numbers
    Token number() {
        while is_digit(this.peek_char()) {
            var dummy = this.advance();
        }
        
        // TODO: Support decimal points (floats)
        
        return this.make_token_from(T_NUMBER());
    }

    // Get next token
    Token scan_token() {
        this.skip_whitespace();
        
        this.start = this.current;
        
        if this.is_at_end() {
            return make_token(T_EOF(), "", this.line, this.column);
        }
        
        var c = this.advance();
        
        // Simple symbols
        if c == "+" { return this.make_token_from(T_PLUS()); }
        if c == "-" { return this.make_token_from(T_MINUS()); }
        if c == "/" { return this.make_token_from(T_SLASH()); }
        if c == "{" { return this.make_token_from(T_LEFT_BRACE()); }
        if c == "}" { return this.make_token_from(T_RIGHT_BRACE()); }
        if c == "*" { return this.make_token_from(T_STAR()); }
        if c == "(" { return this.make_token_from(T_LEFT_PAREN()); }
        if c == ")" { return this.make_token_from(T_RIGHT_PAREN()); }
        if c == ";" { return this.make_token_from(T_SEMICOLON()); }
        if c == ":" { return this.make_token_from(T_COLON()); }
        if c == "." { return this.make_token_from(T_DOT()); }
        if c == "," { return this.make_token_from(T_COMMA()); }

        if c == "!" {
            if this.match_char("=") { return this.make_token_from(T_BANG_EQUAL()); }
            return this.make_token_from(T_BANG());
        }
        if c == "=" { 
            if this.match_char("=") { return this.make_token_from(T_EQUAL_EQUAL()); }
            return this.make_token_from(T_EQUAL()); 
        }
        if c == "<" {
            if this.match_char("=") { return this.make_token_from(T_LESS_EQUAL()); }
            return this.make_token_from(T_LESS());
        }
        if c == ">" {
            if this.match_char("=") { return this.make_token_from(T_GREATER_EQUAL()); }
            return this.make_token_from(T_GREATER());
        }
        
        if c == "&" {
            if this.match_char("&") { return this.make_token_from(T_AND_AND()); }
        }
        if c == "|" {
            if this.match_char("|") { return this.make_token_from(T_OR_OR()); }
        }
        
        // Number literals
        var c_int = this.source[this.start];
        if is_digit(c_int) {
            return this.number();
        }
        
        if c == "=" { return this.make_token_from(T_EQUAL()); }
        
        // Identifier or keyword
        var is_alpha_char = is_alpha(c_int) || c_int == 95; // 95 is '_'
        if is_alpha_char {
            return this.identifier();
        }
        
        // TODO: Support double-char operators (==, !=, etc)
        // TODO: Support string literals
        
        return this.error_token("Unexpected character.");
    }
}
