// lencyc/syntax/ast.lcy
// Lency Self-hosted Compiler - Minimal AST
// Currently supports basic expressions and statements.

import std.core
import lencyc.syntax.token

// 表达式类型
int EXPR_LITERAL() { return 1; }
int EXPR_BINARY()  { return 2; }
int EXPR_VARIABLE() { return 3; }
int EXPR_GROUPING() { return 4; }
int EXPR_UNARY()    { return 5; }
int EXPR_ASSIGN()   { return 6; }
int EXPR_LOGICAL()  { return 7; }

struct Expr {
    int kind
    Token literal_value
    Token operator
    Vec<Expr> children
}

// Helper factory functions

Expr make_expr_literal(Token v) {
    return Expr {
        kind: EXPR_LITERAL(),
        literal_value: v,
        operator: make_token(0, "", 0, 0),
        children: vec![]
    }
}

Expr make_expr_binary(Expr left, Token op, Expr right) {
    var children = vec![left, right]
    return Expr {
        kind: EXPR_BINARY(),
        literal_value: make_token(0, "", 0, 0),
        operator: op,
        children: children
    }
}

Expr make_expr_variable(Token name) {
    return Expr {
        kind: EXPR_VARIABLE(),
        literal_value: name,
        operator: make_token(0, "", 0, 0),
        children: vec![]
    }
}

Expr make_expr_grouping(Expr expression) {
    return Expr {
        kind: EXPR_GROUPING(),
        literal_value: make_token(0, "", 0, 0),
        operator: make_token(0, "", 0, 0),
        children: vec![expression]
    }
}

Expr make_expr_unary(Token op, Expr right) {
    return Expr {
        kind: EXPR_UNARY(),
        literal_value: make_token(0, "", 0, 0),
        operator: op,
        children: vec![right]
    }
}

Expr make_expr_assign(Token name, Expr value) {
    return Expr {
        kind: EXPR_ASSIGN(),
        literal_value: name,
        operator: make_token(0, "", 0, 0),
        children: vec![value]
    }
}

Expr make_expr_logical(Expr left, Token op, Expr right) {
    var children = vec![left, right]
    return Expr {
        kind: EXPR_LOGICAL(),
        literal_value: make_token(0, "", 0, 0),
        operator: op,
        children: children
    }
}

// ==========================================
// Statement types
// ==========================================

int STMT_EXPR()      { return 1; }
int STMT_VAR_DECL()  { return 2; }
int STMT_IF()        { return 3; }
int STMT_BLOCK()     { return 4; }
int STMT_WHILE()     { return 5; }

struct Stmt {
    int kind
    Token name        // 用于 VarDecl, FunctionDecl 等
    Expr expr         // 用于 ExprStmt 等单一表达式语句, 以及 If 的条件
    Vec<Stmt> body    // 用于嵌套结构, 以及 If 的 then 分支
    Vec<Stmt> else_body // 用于 If 的 else 分支
}

// 辅助工厂函数

Stmt make_stmt_expr(Expr expr) {
    return Stmt {
        kind: STMT_EXPR(),
        name: make_token(0, "", 0, 0),
        expr: expr,
        body: vec![]
    }
}

Stmt make_stmt_var_decl(Token name, Expr initializer) {
    return Stmt {
        kind: STMT_VAR_DECL(),
        name: name,
        expr: initializer,
        body: vec![],
        else_body: vec![]
    }
}

Stmt make_stmt_if(Expr condition, Vec<Stmt> then_branch, Vec<Stmt> else_branch) {
    return Stmt {
        kind: STMT_IF(),
        name: make_token(0, "", 0, 0),
        expr: condition,
        body: then_branch,
        else_body: else_branch
    }
}

Stmt make_stmt_block(Vec<Stmt> statements) {
    return Stmt {
        kind: STMT_BLOCK(),
        name: make_token(0, "", 0, 0),
        expr: make_expr_literal(make_token(0, "", 0, 0)),
        body: statements,
        else_body: vec![]
    }
}

Stmt make_stmt_while(Expr condition, Vec<Stmt> body) {
    return Stmt {
        kind: STMT_WHILE(),
        name: make_token(0, "", 0, 0),
        expr: condition,
        body: body,
        else_body: vec![]
    }
}
