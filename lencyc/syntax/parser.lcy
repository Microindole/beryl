// lencyc/syntax/parser.lcy
// Lency Self-hosted Compiler - Recursive Descent Parser
// Currently handles basic math and variable declarations.

import std.core
import lencyc.syntax.token
import lencyc.syntax.lexer
import lencyc.syntax.ast

struct Parser {
    Lexer lexer
    Token current
    Token previous
    bool has_error
}

Parser make_parser(string source) {
    var lexer = make_lexer(source)
    return Parser {
        lexer: lexer,
        current: make_token(0, "", 0, 0),
        previous: make_token(0, "", 0, 0),
        has_error: false
    }
}

impl Parser {
    void error(string message) {
        // TODO: Use a unified Reporter for better error reporting.
        print("Error at " + int_to_string(this.current.line) + ":" + int_to_string(this.current.column) + ": " + message + "\n")
        this.has_error = true
    }
    
    void advance() {
        this.previous = this.current
        
        while true {
            this.current = this.lexer.scan_token()
            if this.current.kind != T_ERROR() {
                break
            }
            this.error(this.current.lexeme)
        }
    }
    
    void consume(int type, string message) {
        if this.current.kind == type {
            this.advance()
            return
        }
        this.error(message)
    }
    
    bool check(int type) {
        return this.current.kind == type
    }
    
    bool match_token(int type) {
        if !this.check(type) {
            return false
        }
        this.advance()
        return true
    }

    // ----------------------------------------------------
    // Pratt Parser / Recursive Descent Expression Parsing Basics
    // ----------------------------------------------------

    Expr expression() {
        return this.assignment()
    }

    Expr assignment() {
        var expr = this.or()
        if this.match_token(T_EQUAL()) {
            var value = this.assignment()
            if expr.kind == EXPR_VARIABLE() {
                return make_expr_assign(expr.literal_value, value)
            }
            this.error("Invalid assignment target.")
        }
        return expr
    }

    Expr or() {
        var expr = this.and()
        while this.match_token(T_OR_OR()) {
            var operator = this.previous
            var right = this.and()
            expr = make_expr_logical(expr, operator, right)
        }
        return expr
    }

    Expr and() {
        var expr = this.equality()
        while this.match_token(T_AND_AND()) {
            var operator = this.previous
            var right = this.equality()
            expr = make_expr_logical(expr, operator, right)
        }
        return expr
    }

    Expr equality() {
        var expr = this.comparison()
        while this.match_token(T_BANG_EQUAL()) || this.match_token(T_EQUAL_EQUAL()) {
            var operator = this.previous
            var right = this.comparison()
            expr = make_expr_binary(expr, operator, right)
        }
        return expr
    }

    Expr comparison() {
        var expr = this.term()
        while this.match_token(T_GREATER()) || this.match_token(T_GREATER_EQUAL()) ||
              this.match_token(T_LESS()) || this.match_token(T_LESS_EQUAL()) {
            var operator = this.previous
            var right = this.term()
            expr = make_expr_binary(expr, operator, right)
        }
        return expr
    }

    Expr term() {
        var expr = this.factor()
        while this.match_token(T_PLUS()) || this.match_token(T_MINUS()) {
            var operator = this.previous
            var right = this.factor()
            expr = make_expr_binary(expr, operator, right)
        }
        return expr
    }
    
    Expr factor() {
        var expr = this.unary()
        while this.match_token(T_STAR()) || this.match_token(T_SLASH()) {
            var operator = this.previous
            var right = this.unary()
            expr = make_expr_binary(expr, operator, right)
        }
        return expr
    }

    Expr unary() {
        if this.match_token(T_BANG()) || this.match_token(T_MINUS()) {
            var operator = this.previous
            var right = this.unary()
            return make_expr_unary(operator, right)
        }
        return this.primary()
    }
    
    Expr primary() {
        if this.match_token(T_NUMBER()) {
            return make_expr_literal(this.previous)
        }
        
        if this.match_token(T_TRUE()) {
            return make_expr_literal(this.previous)
        }
        if this.match_token(T_IDENTIFIER()) {
            return make_expr_variable(this.previous)
        }
        
        if this.match_token(T_LEFT_PAREN()) {
            var expr = this.expression()
            this.consume(T_RIGHT_PAREN(), "Expect ')' after expression.")
            return make_expr_grouping(expr)
        }
        
        this.error("Expect expression.")
        // Return a dummy expression to prevent crashes
        return make_expr_literal(make_token(T_ERROR(), "", 0, 0))
    }
    
    // ----------------------------------------------------
    // Statement parsing
    // ----------------------------------------------------
    
    Stmt var_declaration() {
        this.consume(T_IDENTIFIER(), "Expect variable name.")
        var name = this.previous
        
        this.consume(T_EQUAL(), "Expect '=' after variable name.")
        
        var initializer = this.expression() // Currently, the top-level expression parsing is expression()
        
        return make_stmt_var_decl(name, initializer)
    }

    Vec<Stmt> block() {
        var statements = vec![]
        while !this.check(T_RIGHT_BRACE()) && !this.is_at_end() {
            var stmt = this.declaration()
            statements.push(stmt)
        }
        
        this.consume(T_RIGHT_BRACE(), "Expect '}' after block.")
        return statements
    }

    Stmt if_statement() {
        var condition = this.expression()
        
        this.consume(T_LEFT_BRACE(), "Expect '{' before then block.")
        var then_branch = this.block()
        
        var else_branch: Vec<Stmt> = vec![]
        if this.match_token(T_ELSE()) {
            if this.match_token(T_LEFT_BRACE()) {
                else_branch = this.block()
            } else {
                // Support else if ...
                if this.check(T_IF()) {
                    var dummy = this.match_token(T_IF())
                    var nested_if = this.if_statement()
                    else_branch.push(nested_if)
                } else {
                    this.error("Expect '{' or 'if' after 'else'.")
                }
            }
        }
        
        return make_stmt_if(condition, then_branch, else_branch)
    }

    Stmt while_statement() {
        var condition = this.expression()
        this.consume(T_LEFT_BRACE(), "Expect '{' before while body.")
        var body = this.block()
        return make_stmt_while(condition, body)
    }

    Stmt statement() {
        if this.match_token(T_LEFT_BRACE()) {
            return make_stmt_block(this.block())
        }
        
        // Expression statement
        var expr = this.expression()
        return make_stmt_expr(expr)
    }

    Stmt declaration() {
        if this.match_token(T_VAR()) {
            return this.var_declaration()
        }
        
        if this.match_token(T_IF()) {
            return this.if_statement()
        }
        
        if this.match_token(T_WHILE()) {
            return this.while_statement()
        }
        
        return this.statement()
    }
    
    // Parser Entry Point
    Vec<Stmt> parse() {
        var statements = vec![]
        this.advance() // 启动 parser
        
        while !this.is_at_end() {
            var stmt = this.declaration()
            statements.push(stmt)
            if this.has_error {
                break
            }
        }
        return statements
    }
    
    bool is_at_end() {
        return this.current.kind == T_EOF()
    }
}
